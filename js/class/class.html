<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>try Class</title>
    <script>
        // 严格模式的优点：
        // 1. 禁止一些语法
        // 2. 更容易报错
        // 3. 提升了性能
        "use strict";
        // a = 10 // 在严格模式下，此行代码运行会报错
        class Person {
            name="this is Person name";
            static show() {
                console.log("Person static show: " + this.name);
            }
            static className="Person"
        }
        let p = new Person();
        console.log(p)
        console.log(Person.show());
        console.log(Person.className);

        class Dog {
            #name
            #age // 私有属性必须先声明
            constructor(name, age) {
                this.#name = name;
                this.#age = age;
            }
            show() {
                console.log(this.#name, this.#age)
            }

            get name() {
                return this.#name;
            }

            // 可以使用 obj.age 直接获得 age 属性
            get age() {
                return this.#age;
            }

            // 可以用 obj.age = 2 // 来直接设置属性
            set age(age) {
                this.#age = age;
            }
        }

        const d1 = new Dog("小黑", 1);
        console.log(d1);
        // 不能再使用 d1.#name 访问，报错：Uncaught SyntaxError: Private field '#name' must be declared in an enclosing class
        // 但是可以提供 get 和 set 方法

        class Animal {
            constructor(name) {
                this.name = name
            }

            sayHello() {
                console.log("动物在叫")
            }
        }

        class Cat extends Animal {
            sayHello() {
                console.log("喵喵喵")
            }
        }
        const cat = new Cat("Tom")
        console.log(cat)
        cat.sayHello()

        // 函数里面的代码默认是严格模式
        class Pig extends Animal {
            constructor(name, age) {
                super(name) // super() 必须调用，否则会报错
                this.age = age
            }

            sayHello() {
                super.sayHello() // 重写父类的 sayHello() 函数，可以使用 super.调用父类的属性和方法
                console.log("哼哼")
            }
        }
        const pig = new Pig("Li")
        pig.sayHello()

        let fn = ()=>{
            "use strict";
            name = "luojie"
            console.log(name);
        }
        fn()

        console.log(pig.__proto__) // Animal {constructor: ƒ, sayHello: ƒ}
        console.log(pig.__proto__ == Pig.prototype) // true
        console.log(pig.__proto__.__proto__) // {constructor: ƒ, sayHello: ƒ}
        console.log(pig.__proto__.__proto__.__proto__) // {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}
        console.log(pig.__proto__.__proto__.__proto__.__proto__) // null

        // 原型链根据类的复杂程序不同而展示不同的结果
        // console.log(Object.hasOwnProperty(pig, "age"));
        // 无论属性是在对象中或者原型中，in 都能取到
        console.log("name" in pig) // true
        console.log("sayHello" in pig) // true

        // 使用 对象.hasOwnProperty 时，只能获取到对象中存储的属性
        console.log(pig.hasOwnProperty("name")) // true
        console.log(pig.hasOwnProperty("sayHello")) // false
        // 对象.hasOwnProperty 不推荐使用，建议使用 Object.hasOwn
        console.log(Object.hasOwn(pig, "name")) // true
        console.log(Object.hasOwn(pig, "sayHello")) // false

        // 通过对象能访问到的方法，若不在对象自身的存储中，则该方法一定会出现在对象的原型链上
        // 函数能正常访问，它一定在 Window 对象中定义中了

        // 比较旧的类的实现
        function Book(name, author) {
            this.name = name;
            this.author = author;
            /*不能在构造函数中写此类代码，需要通过原型来操作
            this.sayHello = function() {

            }*/
        }

        Book.prototype.sayHello = function() {

       }

        const b = new Book("代码整洁之道", "Martin");
        console.log(b);
    </script>
</head>
<body>
    
</body>
</html>